#include "internal.hpp"
#include "kinematics.hpp"
#include "model.hpp"
#include "planner.hpp"
#include "constants.hpp"
#include "interpolation.hpp"
#include "sequencer.hpp"
#include "types.hpp"
#include "utils/coordinates.hpp"
#include <algorithm>
#include <cmath>
#include <functional>
#include <initializer_list>
#include <iostream>
#include <limits>
#include <list>

namespace planner {

/// Converts the os positions generated by @p f to js positions.
/// @param robot The robot.
/// @param current_pose The current pose of the robot.
/// @param result The sequence where to store the results.
/// @param f The function generating the os positions.
/// @param duration The duration of the movement.
/// @param dt The time simulation unit.
template<class Robot, class Function>
std::function<std::tuple<typename Robot::Configuration, bool>()> to_js_trajectory(
  Robot& robot,
  const os::Position& current,
  Function&& f,
  const Time& duration,
  const Time& dt
) {
  // NOTE Depends on robot status and modifies it. Cannot reiterate.
  return [&robot, current = current, f = std::move(f), duration, dt, t = Time(0)]() mutable {
    #ifdef JOINT_SPACE_PLANNING
    robot.config = f(t);
    t += dt;
    #else
    const os::Position next_pose = f(t + dt);
    const os::Velocity ov = (next_pose - current) / 1.0;

    // NOTE: Last minute patch. Movements passed to the inverse diff instead of velocities.
    const js::Velocity jv = kinematics::dpa_inverse_diff(robot, ov, current, 1.0);

    // Enforcing max joint speed with time dilation.
    const Scalar time_factor = std::min(1.0, Robot::max_joint_speed / jv.norm() * dt);
    robot.config += jv * time_factor;

    t += dt * time_factor;

    // Could be different from `next_pose`.
    current = f(t);

    #endif

    return std::make_tuple(robot.config, t >= duration);
  };
}

template<coord::LinearSystem ls, coord::AngularSystem as>
auto generate_positions(
  const model::UR5& robot,
  const model::UR5::Configuration& current_config,
  const kinematics::Pose<as, ls>& current_pose,
  const os::Position& pose
) {
  using Position = kinematics::Pose<as, ls>;

  // Pose outside of the low-zone just above the `pose`.
  Position safe_pose = planner::safe_pose(pose);

  const Position safe_current_pose = planner::safe_pose(current_pose);

  const auto js_pos = kinematics::inverse(robot, safe_pose);

  // Just to throw exceptions prematurely in case of unreachability.
  kinematics::inverse(robot, pose);

  ViaPoints via_points;

  if (unsafe(current_pose)) via_points.push_back(safe_current_pose);

  // TODO FIXME: this fails when the joint space requires a rotation > 2pi.
  // The midpoint will force a rotation in the wrong direction.
  // This can be fixed with a more sophisticated inverse kinematics.
  #ifndef JOINT_SPACE_PLANNING
  if constexpr (as == coord::Lie) {
    // The mid point in the joint space interpolation.
    const auto js_pos_mid = current_config + (js_pos - current_config) / 2 * 1;

    // The mid point in the operational space interpolation.
    const auto os_pos_mid = safe_current_pose + (safe_pose - safe_current_pose) / 2 * 1;

    // The operational space view of `js_pos_mid`.
    const Position os_js_pos_mid = kinematics::direct(robot, js_pos_mid);

    // The wanted mid-point.
    // NOTE: all this is necessary to force the correct orientation of the end effector to avoid
    //       violations of the joint limits with coord::Lie interpolation.
    Position mid_pose(os_pos_mid.linear(), os_js_pos_mid.angular());

    // The angular distance to the mid point is at more than pi/2 radiants.
    // This means that the angular distance to the desired orientation is more than pi.
    // The interpolation will naturally take the other way around.
    // We force the passage through the mid point by adding it as a via point.
    if (safe_current_pose.angular().angularDistance(mid_pose.angular()) > M_PI_2) {
      via_points.push_back(std::move(mid_pose));
    }
  }
  #endif

  if (unsafe(pose)) {
    via_points.push_back(std::move(safe_pose));
  }


  return std::make_tuple(via_points, pose, js_pos);
}


/// Generates the sequence of movements from the initial @p robot configuration, throught the picking
/// of one block from its starting position, to the relase of the block into its target position.
/// @param robot The current robot configuration.
/// @param end The destination position.
/// @param dt The time granularity.
/// @return A sequence of configurations in order to perform the given movement.
/// @throw std::domain_error If one of the positions is not in the operational space.
MovementSequence::ConfigGenerator plan_movement(model::UR5& robot, const os::Position& end, const Time& dt) {
  constexpr coord::LinearSystem ls = coord::Cylindrical;
  constexpr coord::AngularSystem as = coord::Lie;

  os::Position current_pose = kinematics::direct(robot);

  const auto [viapt, end_pose, end_config] = generate_positions<ls, as>(
    robot, robot.config, current_pose, end
  );

  Time finish_time;

  auto movement = via_point_sequencer<ls, as>(current_pose, viapt, end_pose, finish_time);

  return to_js_trajectory(robot, current_pose, movement, finish_time, dt);
}

/// Generates the sequence of movements from the initial @p robot configuration, throught the picking
/// of one block from its starting position, to the relase of the block into its target position.
/// @param robot The current robot configuration.
/// @param movement The requested block movement.
/// @param dt The time granularity.
/// @return A sequence of configuration variations in order to perform the given movement.
/// @throw std::domain_error If one of the positions is not in the operational space.
/// @note Evaluate if its worth to run this into a thread in order to perform the next calculations
///       during the physical driving of the robot for the previous movement.
MovementSequence plan_movement(model::UR5& robot, const BlockMovement& movement, const Time& dt) {
  constexpr coord::LinearSystem ls = coord::Cylindrical;
  constexpr coord::AngularSystem as = coord::Lie;

  os::Position current_pose = kinematics::direct(robot);

  const auto [picking_viapt, picking_end, picking_end_config] = generate_positions<ls, as>(
    robot, robot.config, current_pose, movement.start.to_os_position()
  );

  const auto [dropping_viapt, dropping_end, _] = generate_positions<ls, as>(
    robot, picking_end_config, movement.start.to_os_position(), movement.target.to_os_position()
  );

  Time finish_time_picking;
  Time finish_time_dropping;

  auto picking = via_point_sequencer<ls, as>(current_pose, picking_viapt, picking_end, finish_time_picking);
  auto dropping = via_point_sequencer<ls, as>(picking_end, dropping_viapt, dropping_end, finish_time_dropping);

  MovementSequence seq{
    to_js_trajectory(robot, current_pose, picking, finish_time_picking, dt),
    to_js_trajectory(robot, picking_end, dropping, finish_time_dropping, dt),
  };

  return seq;
}


}
