#include "internal.hpp"
#include "kinematics.hpp"
#include "planner.hpp"
#include "constants.hpp"
#include "interpolation.hpp"
#include "sequencer.hpp"
#include "types.hpp"
#include "utils/coordinates.hpp"
#include <algorithm>
#include <cmath>
#include <functional>
#include <initializer_list>
#include <limits>
#include <list>

namespace planner {

/// Converts the os positions generated by @p f to js positions.
/// @param robot The robot.
/// @param current_pose The current pose of the robot.
/// @param result The sequence where to store the results.
/// @param f The function generating the os positions.
/// @param duration The duration of the movement.
/// @param dt The time simulation unit.
template<class Function>
void to_js_trajectory(
  model::UR5& robot,
  os::Position& current_pose,
  MovementSequence::ConfigSequence& result,
  Function&& f,
  const Time& duration,
  const Time& dt
) {
  // TODO: can skip some steps, however it is not a problem, isn't it?
  //        Also the finish time could be != duration.
  for (Time t = 0; t <= duration; t += dt) {
    #ifdef JOINT_SPACE_PLANNING
    robot.config = f(t);
    result.push(robot.config);
    #else
    os::Position next_pose = f(t);

    const os::Velocity ov = (next_pose - current_pose) / dt;

    const js::Velocity jv = kinematics::dpa_inverse_diff(robot, ov, current_pose, dt);

    robot.config += jv * dt;

    result.push(robot.config);

    current_pose = std::move(next_pose);
    #endif
  }
}


/// Generates the sequence of movements from the initial @p robot configuration, throught the picking
/// of one block from its starting position, to the relase of the block into its target position.
/// @param robot The current robot configuration.
/// @param movement The requested block movement.
/// @param dt The time granularity.
/// @return A sequence of configuration variations in order to perform the given movement.
/// @throw std::domain_error If one of the positions is not in the operational space.
/// @note Evaluate if its worth to run this into a thread in order to perform the next calculations
///       during the physical driving of the robot for the previous movement.
MovementSequence plan_movement(model::UR5& robot, const BlockMovement& movement, const Time& dt) {
  const os::Position start_pose = block_pose_to_pose(movement.start.pose);
  const os::Position target_pose = block_pose_to_pose(movement.target.pose);

  // Pose outside of the low-zone just above the `start_pose`.
  const os::Position start_safe_pose = safe_pose(start_pose);
  
  // Pose outside of the low-zone just above the `target_pose`.
  const os::Position target_safe_pose = safe_pose(target_pose);

  // NOTE: only to throw exceptions prematurely in case of unreachability.
  kinematics::inverse(robot, start_safe_pose);
  kinematics::inverse(robot, target_safe_pose);
  kinematics::inverse(robot, start_pose);
  kinematics::inverse(robot, target_pose);

  MovementSequence seq;

  ViaPoints picking_viapt{start_safe_pose};
  ViaPoints dropping_viapt{start_safe_pose, target_safe_pose};
  
  os::Position current_pose = kinematics::direct(robot);

  if (unsafe(current_pose)) {
    picking_viapt.push_front(safe_pose(current_pose));
  }

  Time finish_time;

  auto picking = via_point_sequencer<coord::Cylindrical, coord::Euler>(current_pose, picking_viapt, start_pose, finish_time);
  to_js_trajectory(robot, current_pose, seq.picking, picking, finish_time, dt);

  auto dropping = via_point_sequencer<coord::Cylindrical, coord::Euler>(start_pose, dropping_viapt, target_pose, finish_time);
  to_js_trajectory(robot, current_pose, seq.dropping, dropping, finish_time, dt);

  return seq;
}


}
